This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
build.rs
Cargo.toml
omni.dll
src/cost_model.rs
src/ffi.rs
src/lib.rs
src/main.rs
temp.ptx
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="build.rs">
use cmake::Config;

fn main() {
    // Re-run if C++ files change
    println!("cargo:rerun-if-changed=../cpp_core/library.cpp");
    println!("cargo:rerun-if-changed=../cpp_core/CMakeLists.txt");

    // Build the C++ library using cmake
    let dst = Config::new("../cpp_core").build();

    // Tell cargo to link the static library
    println!("cargo:rustc-link-search=native={}/lib", dst.display());
    println!("cargo:rustc-link-lib=static=omni");

    // Link C++ standard library on Windows (MSVC)
    #[cfg(target_os = "windows")]
    {
        println!("cargo:rustc-link-lib=msvcrt");
    }

    // Link C++ standard library on Unix
    #[cfg(target_os = "linux")]
    {
        println!("cargo:rustc-link-lib=stdc++");
    }

    #[cfg(target_os = "macos")]
    {
        println!("cargo:rustc-link-lib=c++");
    }

    // Copy the DLL to the project root so the executable can find it
    let dll_path = dst.join("bin/omni.dll");
    let target_path = std::env::var("CARGO_MANIFEST_DIR").unwrap() + "/omni.dll";

    println!("cargo:warning=Copying DLL from {:?} to {:?}", dll_path, target_path);
    std::fs::copy(dll_path, target_path).expect("Failed to copy DLL to root!");
}
</file>

<file path="Cargo.toml">
[package]
name = "rust_tooling"
version = "0.1.0"
edition = "2021"

[dependencies]
libc = "0.2"
regex = "1.10"
rayon = "1.8"
lazy_static = "1.4"
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"

[build-dependencies]
cc = "1.0"
bindgen = "0.69"
cmake = "0.1"
</file>

<file path="src/cost_model.rs">
//! PTX Cost Model
//! 
//! Parses PTX assembly text and converts instructions to opcodes
//! for the GPU simulator.

use lazy_static::lazy_static;
use regex::Regex;

lazy_static! {
    // Match LD.SHARED with optional stride: "LD.SHARED" or "LD.SHARED:32"
    static ref LD_SHARED_RE: Regex = Regex::new(r"(?i)LD\.SHARED(?::(\d+))?").unwrap();
    static ref MMA_SYNC_RE: Regex = Regex::new(r"(?i)MMA\.SYNC").unwrap();
}

/// Parse PTX assembly text and extract instruction opcodes.
/// 
/// # Opcode Encoding
/// Encoded as: `opcode | (stride << 8)`
/// - `LD.SHARED` -> 1 (shared memory load), stride encoded in upper bits
/// - `LD.SHARED:N` -> 1 with stride N
/// - `MMA.SYNC` -> 2 (tensor core matrix multiply)
/// - Others -> 0 (generic ALU operation)
/// 
/// # Arguments
/// * `ptx` - PTX assembly text (one instruction per line)
/// 
/// # Returns
/// Vector of encoded opcodes suitable for the simulator.
pub fn parse_ptx(ptx: &str) -> Vec<u32> {
    ptx.lines()
        .filter(|line| !line.trim().is_empty())
        .map(|line| {
            let line = line.trim();
            
            // Check for LD.SHARED with optional stride
            if let Some(caps) = LD_SHARED_RE.captures(line) {
                let stride: u32 = caps.get(1)
                    .map(|m| m.as_str().parse().unwrap_or(1))
                    .unwrap_or(1);
                // Encode: opcode=1, stride in upper bits
                1 | (stride << 8)
            } else if MMA_SYNC_RE.is_match(line) {
                2 // MMA.SYNC
            } else {
                0 // Default ALU
            }
        })
        .collect()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_parse_ptx() {
        let ptx = "LD.SHARED\nMMA.SYNC\nADD\n";
        let opcodes = parse_ptx(ptx);
        assert_eq!(opcodes, vec![1 | (1 << 8), 2, 0]);
    }

    #[test]
    fn test_parse_with_stride() {
        let ptx = "LD.SHARED:32\n";
        let opcodes = parse_ptx(ptx);
        assert_eq!(opcodes, vec![1 | (32 << 8)]);
    }
}
</file>

<file path="src/ffi.rs">
//! Foreign Function Interface for C++ GPU simulator
//! 
//! Provides safe Rust wrappers around unsafe C++ calls.

extern "C" {
    fn debug_gpu(id: libc::c_int) -> libc::c_int;
    fn simulate_trace(instructions: *const u32, length: libc::c_int) -> u32;
}

/// Safe wrapper around the C++ GPU simulator.
/// 
/// Implements Drop to ensure proper cleanup (future-proofing for 
/// when we allocate dynamic C++ memory).
pub struct Simulator {
    _initialized: bool,
}

impl Simulator {
    /// Create a new simulator instance.
    pub fn new() -> Self {
        Simulator { _initialized: true }
    }

    /// Run the legacy debug function (for testing FFI).
    pub fn debug(&self, id: i32) -> i32 {
        unsafe { debug_gpu(id) }
    }

    /// Simulate a GPU trace and return total latency in cycles.
    /// 
    /// # Arguments
    /// * `instructions` - Slice of opcodes (1=LD.SHARED, 2=MMA.SYNC, 0=ALU)
    /// 
    /// # Returns
    /// Total simulated latency in cycles.
    pub fn simulate(&self, instructions: &[u32]) -> u32 {
        unsafe { 
            simulate_trace(instructions.as_ptr(), instructions.len() as libc::c_int) 
        }
    }
}

impl Default for Simulator {
    fn default() -> Self {
        Self::new()
    }
}

impl Drop for Simulator {
    fn drop(&mut self) {
        // Future: Call C++ cleanup functions here if we allocate memory
        // For now, this is a placeholder for good practice.
        self._initialized = false;
    }
}
</file>

<file path="src/lib.rs">
//! OmniTrace GPU Simulator Library
//!
//! Provides PTX parsing and GPU trace simulation through C++ FFI.

pub mod ffi;
pub mod cost_model;

pub use ffi::Simulator;
pub use cost_model::parse_ptx;

/// Run a complete simulation from PTX text to latency result.
///
/// This is the main entry point for the library. It parses the PTX,
/// runs the C++ simulation, and returns the total latency.
///
/// # Arguments
/// * `ptx` - PTX assembly text (one instruction per line)
///
/// # Returns
/// Total simulated latency in cycles.
pub fn run_simulation(ptx: &str) -> u64 {
    let sim = Simulator::new();
    let opcodes = parse_ptx(ptx);
    sim.simulate(&opcodes) as u64
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_basic_math() {
        // Two ALU operations = 2 cycles
        let latency = run_simulation("ADD\nADD");
        assert_eq!(latency, 2, "Two ADD instructions should take 2 cycles");
    }

    #[test]
    fn test_tensor_core() {
        // MMA.SYNC = 16 cycles (H100 tensor core latency)
        let latency = run_simulation("MMA.SYNC");
        assert_eq!(latency, 16, "MMA.SYNC should take 16 cycles");
    }

    #[test]
    fn test_mixed() {
        // LD.SHARED (stride=1, no conflicts = 1 cycle) + MMA.SYNC (16 cycles) = 17 cycles
        let latency = run_simulation("LD.SHARED\nMMA.SYNC");
        assert_eq!(latency, 17, "LD.SHARED + MMA.SYNC should take 17 cycles");
    }
}
</file>

<file path="src/main.rs">
use std::fs;
use std::env;

fn main() {
    // Get filename from command line
    let args: Vec<String> = env::args().collect();
    if args.len() < 2 {
        eprintln!("Usage: {} <ptx_file>", args[0]);
        std::process::exit(1);
    }

    let filename = &args[1];
    
    // Read PTX file
    let ptx_code = match fs::read_to_string(filename) {
        Ok(content) => content,
        Err(e) => {
            eprintln!("Error reading file: {}", e);
            std::process::exit(1);
        }
    };

    // Run simulation via library
    let latency = rust_tooling::run_simulation(&ptx_code);

    // Output ONLY JSON
    println!("{}", serde_json::json!({ "latency": latency }));
}
</file>

<file path="temp.ptx">
LD.SHARED:1
LD.SHARED:1
LD.SHARED:1
LD.SHARED:1
LD.SHARED:1
LD.SHARED:1
LD.SHARED:1
LD.SHARED:1
LD.SHARED:1
LD.SHARED:1
LD.SHARED:1
LD.SHARED:1
LD.SHARED:1
LD.SHARED:1
LD.SHARED:1
LD.SHARED:1
LD.SHARED:1
LD.SHARED:1
LD.SHARED:1
LD.SHARED:1
LD.SHARED:1
LD.SHARED:1
LD.SHARED:1
LD.SHARED:1
LD.SHARED:1
LD.SHARED:1
LD.SHARED:1
LD.SHARED:1
LD.SHARED:1
LD.SHARED:1
LD.SHARED:1
LD.SHARED:1
</file>

</files>
